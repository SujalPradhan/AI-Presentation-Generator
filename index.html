<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Auto PPT Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .form-section {
            margin-bottom: 30px;
        }

        .form-section h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            width: 24px;
            height: 24px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4b5563;
        }

        textarea, input[type="text"], input[type="file"], select {
            width: 100%;
            padding: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: #f9fafb;
        }

        textarea:focus, input:focus, select:focus {
            outline: none;
            border-color: #4f46e5;
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        textarea {
            min-height: 200px;
            resize: vertical;
        }

        .api-config {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
            align-items: end;
        }

        .tone-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .tone-option {
            padding: 10px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f9fafb;
        }

        .tone-option:hover {
            border-color: #4f46e5;
            background: #eef2ff;
        }

        .tone-option.selected {
            border-color: #4f46e5;
            background: #4f46e5;
            color: white;
        }

        .generate-btn {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 30px;
        }

        .generate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(79, 70, 229, 0.4);
        }

        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f46e5, #7c3aed);
            width: 0%;
            transition: width 0.5s ease;
        }

        .status {
            text-align: center;
            margin: 20px 0;
            font-weight: 600;
        }

        .preview-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8fafc;
            border-radius: 12px;
            display: none;
        }

        .slide-preview {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: white;
        }

        .slide-title {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: #374151;
        }

        .slide-content {
            color: #6b7280;
            line-height: 1.5;
        }

        .error {
            color: #dc2626;
            background: #fef2f2;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #dc2626;
            margin: 15px 0;
        }

        .success {
            color: #059669;
            background: #ecfdf5;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #059669;
            margin: 15px 0;
        }

        .file-info {
            font-size: 0.9rem;
            color: #6b7280;
            margin-top: 5px;
        }

        .template-info {
            background: #f0f9ff;
            border: 1px solid #38bdf8;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .template-info h4 {
            margin-bottom: 10px;
            color: #0369a1;
        }

        .template-details {
            font-size: 0.9rem;
            color: #0369a1;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .api-config {
                grid-template-columns: 1fr;
            }
            
            .tone-options {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Enhanced Auto PPT Generator</h1>
            <p>Transform your text into professional PowerPoint presentations with template preservation</p>
        </div>
        
        <div class="main-content">
            <form id="pptForm">
                <!-- Text Input Section -->
                <div class="form-section">
                    <h2>
                        <span class="icon">üìù</span>
                        Your Content
                    </h2>
                    <div class="input-group">
                        <label for="textInput">Paste your text, markdown, or prose:</label>
                        <textarea id="textInput" placeholder="Enter your content here... Supports plain text, markdown, and structured prose. The AI will intelligently break this into slides." required></textarea>
                    </div>
                    
                    <div class="input-group">
                        <label for="guidance">Optional guidance (tone, structure, use case):</label>
                        <input type="text" id="guidance" placeholder="e.g., 'Professional investor pitch for a SaaS startup' or 'Technical presentation for engineers'">
                    </div>

                    <div class="input-group">
                        <label>Quick Tone Selection:</label>
                        <div class="tone-options">
                            <div class="tone-option" data-tone="professional">üìä Professional</div>
                            <div class="tone-option" data-tone="investor">üíº Investor Pitch</div>
                            <div class="tone-option" data-tone="technical">‚öôÔ∏è Technical</div>
                            <div class="tone-option" data-tone="educational">üéì Educational</div>
                            <div class="tone-option" data-tone="creative">üé® Creative</div>
                            <div class="tone-option" data-tone="sales">üìà Sales</div>
                        </div>
                    </div>
                </div>

                <!-- Template Upload Section -->
                <div class="form-section">
                    <h2>
                        <span class="icon">üìé</span>
                        PowerPoint Template
                    </h2>
                    <div class="input-group">
                        <label for="templateFile">Upload your PowerPoint template (.pptx or .potx):</label>
                        <input type="file" id="templateFile" accept=".pptx,.potx" required>
                        <div class="file-info">The generated presentation will match your template's style, colors, fonts, and layouts.</div>
                        <div class="template-info" id="templateInfo">
                            <h4>üìã Template Analysis</h4>
                            <div class="template-details" id="templateDetails">
                                Upload a template to see analysis details...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- API Configuration Section -->
                <div class="form-section">
                    <h2>
                        <span class="icon">üîë</span>
                        AI Configuration
                    </h2>
                    <div class="api-config">
                        <div class="input-group">
                            <label for="apiProvider">AI Provider:</label>
                            <select id="apiProvider" required>
                                <option value="">Select Provider</option>
                                <option value="openai" selected>OpenAI (GPT-3.5-Turbo) - Recommended</option>
                                <option value="anthropic">Anthropic (Claude 3 Haiku) - Free Tier</option>
                                <option value="gemini">Google (Gemini 1.5 Flash) - Free Tier</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="apiKey">API Key (never stored or logged):</label>
                            <input type="password" id="apiKey" placeholder="Your API key - processed securely in-browser only" required>
                            <div class="file-info" id="apiKeyInfo">
                                OpenAI: Get free $5 credit at platform.openai.com/api-keys
                            </div>
                        </div>
                    </div>
                </div>

                <button type="submit" class="generate-btn" id="generateBtn">
                    üöÄ Generate PowerPoint Presentation
                </button>
            </form>

            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="status" id="status"></div>
            
            <div class="preview-section" id="previewSection">
                <h3>üìã Slide Preview</h3>
                <div id="slidePreview"></div>
            </div>
        </div>
    </div>

    <script>
        class EnhancedPPTGenerator {
            constructor() {
                this.initializeEventListeners();
                this.slideStructure = [];
                this.templateData = null;
            }

            initializeEventListeners() {
                document.getElementById('pptForm').addEventListener('submit', (e) => this.handleFormSubmit(e));
                
                // Tone selection
                document.querySelectorAll('.tone-option').forEach(option => {
                    option.addEventListener('click', (e) => this.selectTone(e.target));
                });

                // API provider info updates
                document.getElementById('apiProvider').addEventListener('change', (e) => this.updateApiInfo(e.target.value));

                // Template file analysis
                document.getElementById('templateFile').addEventListener('change', (e) => this.analyzeTemplate(e));
            }

            selectTone(element) {
                document.querySelectorAll('.tone-option').forEach(opt => opt.classList.remove('selected'));
                element.classList.add('selected');
                
                const guidance = document.getElementById('guidance');
                const toneMap = {
                    'professional': 'Professional business presentation with formal tone',
                    'investor': 'Investor pitch deck focusing on business opportunity and growth',
                    'technical': 'Technical presentation for engineering or scientific audience',
                    'educational': 'Educational content for learning and knowledge sharing',
                    'creative': 'Creative and engaging presentation with storytelling elements',
                    'sales': 'Sales-focused presentation to drive conversions and engagement'
                };
                
                if (!guidance.value) {
                    guidance.value = toneMap[element.dataset.tone] || '';
                }
            }

            async analyzeTemplate(event) {
                const file = event.target.files[0];
                if (!file) return;

                const validExtensions = ['.pptx', '.potx'];
                const fileName = file.name.toLowerCase();
                const isValid = validExtensions.some(ext => fileName.endsWith(ext));
                
                if (!isValid) {
                    this.showError('Please upload a valid PowerPoint file (.pptx or .potx)');
                    event.target.value = '';
                    return;
                } 
                
                if (file.size > 50 * 1024 * 1024) { // 50MB limit
                    this.showError('File size too large. Please upload a file smaller than 50MB.');
                    event.target.value = '';
                    return;
                }

                try {
                    this.showStatus('Analyzing template...', 'info');
                    this.templateData = await this.readTemplateFile(file);
                    this.displayTemplateAnalysis();
                    this.showStatus('Template analyzed successfully!', 'success');
                } catch (error) {
                    console.error('Template analysis error:', error);
                    this.showError('Error analyzing template: ' + error.message);
                }
            }

            displayTemplateAnalysis() {
                const templateInfo = document.getElementById('templateInfo');
                const templateDetails = document.getElementById('templateDetails');
                
                if (this.templateData) {
                    const layouts = Object.keys(this.templateData.slideLayouts).length;
                    const masters = Object.keys(this.templateData.slideMasters).length;
                    const themes = Object.keys(this.templateData.themes).length;
                    const media = Object.keys(this.templateData.media).length;
                    
                    templateDetails.innerHTML = `
                        <div>‚úì ${layouts} slide layout(s) found</div>
                        <div>‚úì ${masters} slide master(s) extracted</div>
                        <div>‚úì ${themes} theme(s) preserved</div>
                        <div>‚úì ${media} media file(s) included</div>
                        <div style="margin-top: 8px; font-weight: 600;">Template styling will be preserved in generated slides</div>
                    `;
                    templateInfo.style.display = 'block';
                }
            }

            async handleFormSubmit(event) {
                event.preventDefault();
                
                const textInput = document.getElementById('textInput').value.trim();
                const guidance = document.getElementById('guidance').value.trim();
                const apiProvider = document.getElementById('apiProvider').value;
                const apiKey = document.getElementById('apiKey').value.trim();
                const templateFile = document.getElementById('templateFile').files[0];

                if (!textInput || !apiProvider || !apiKey || !templateFile) {
                    this.showError('Please fill in all required fields.');
                    return;
                }

                if (!this.templateData) {
                    this.showError('Please wait for template analysis to complete.');
                    return;
                }

                try {
                    this.setLoading(true);
                    this.showStatus('Processing your content with AI...', 'info');
                    this.updateProgress(20);

                    // Process text with LLM
                    const slideData = await this.processTextWithLLM(textInput, guidance, apiProvider, apiKey);
                    this.updateProgress(50);
                    
                    // Show preview
                    this.showPreview(slideData);
                    this.showStatus('Generating presentation with template styling...', 'info');
                    this.updateProgress(70);

                    // Generate PowerPoint with template
                    const pptBlob = await this.generatePowerPointWithTemplate(slideData, this.templateData);
                    this.updateProgress(100);

                    // Download the file
                    this.downloadFile(pptBlob, 'Generated_Presentation.pptx');
                    this.showStatus('‚úÖ PowerPoint presentation generated successfully!', 'success');

                } catch (error) {
                    console.error('Error generating presentation:', error);
                    this.showError('Error generating presentation: ' + error.message);
                } finally {
                    this.setLoading(false);
                }
            }

            async processTextWithLLM(text, guidance, provider, apiKey) {
                const prompt = `You are an expert presentation designer. Convert the following text into a structured PowerPoint presentation.

Text to convert: """${text}"""

${guidance ? `Additional guidance: ${guidance}` : ''}

Please analyze the content and create a logical slide structure. Return ONLY a valid JSON object with this exact format:
{
    "title": "Main Presentation Title",
    "slides": [
        {
            "type": "title",
            "title": "Presentation Title",
            "subtitle": "Optional subtitle"
        },
        {
            "type": "content",
            "title": "Slide Title",
            "content": ["Bullet point 1", "Bullet point 2", "Bullet point 3"],
            "notes": "Optional speaker notes"
        }
    ]
}

Guidelines:
- Create 5-15 slides depending on content length
- First slide should be type "title" 
- Remaining slides should be type "content"
- Break content into logical sections
- Use clear, concise bullet points
- Include speaker notes when helpful
- Ensure professional language and structure`;

                let response;
                const apiKeySecure = apiKey; // Process in memory only - never logged

                try {
                    switch (provider) {
                        case 'openai':
                            response = await fetch('https://api.openai.com/v1/chat/completions', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKeySecure}`
                                },
                                body: JSON.stringify({
                                    model: 'gpt-3.5-turbo',
                                    messages: [{ role: 'user', content: prompt }],
                                    temperature: 0.7,
                                    max_tokens: 1500
                                })
                            });
                            break;

                        case 'anthropic':
                            response = await fetch('https://api.anthropic.com/v1/messages', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'x-api-key': apiKeySecure,
                                    'anthropic-version': '2023-06-01'
                                },
                                body: JSON.stringify({
                                    model: 'claude-3-haiku-20240307',
                                    messages: [{ role: 'user', content: prompt }],
                                    max_tokens: 1500
                                })
                            });
                            break;

                        case 'gemini':
                            response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKeySecure}`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    contents: [{ parts: [{ text: prompt }] }],
                                    generationConfig: { 
                                        temperature: 0.7, 
                                        maxOutputTokens: 1500,
                                        candidateCount: 1
                                    }
                                })
                            });
                            break;

                        default:
                            throw new Error('Unsupported API provider');
                    }

                    if (!response.ok) {
                        const errorData = await response.text();
                        throw new Error(`API request failed (${response.status}): ${errorData}`);
                    }

                    const data = await response.json();
                    let content;

                    switch (provider) {
                        case 'openai':
                            content = data.choices[0].message.content;
                            break;
                        case 'anthropic':
                            content = data.content[0].text;
                            break;
                        case 'gemini':
                            content = data.candidates[0].content.parts[0].text;
                            break;
                    }

                    // Extract JSON from response
                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) {
                        throw new Error('Invalid response format from AI provider');
                    }

                    const slideData = JSON.parse(jsonMatch[0]);
                    
                    // Validate structure
                    if (!slideData.slides || !Array.isArray(slideData.slides)) {
                        throw new Error('Invalid slide structure received');
                    }

                    return slideData;

                } catch (error) {
                    throw new Error(`LLM processing failed: ${error.message}`);
                }
            }

            showPreview(slideData) {
                const previewSection = document.getElementById('previewSection');
                const slidePreview = document.getElementById('slidePreview');
                
                slidePreview.innerHTML = '';
                
                slideData.slides.forEach((slide, index) => {
                    const slideElement = document.createElement('div');
                    slideElement.className = 'slide-preview';
                    
                    if (slide.type === 'title') {
                        slideElement.innerHTML = `
                            <div class="slide-title">Slide ${index + 1}: Title Slide</div>
                            <div class="slide-content">
                                <strong>${slide.title}</strong>
                                ${slide.subtitle ? `<br><em>${slide.subtitle}</em>` : ''}
                            </div>
                        `;
                    } else {
                        const contentList = Array.isArray(slide.content) ? 
                            slide.content.map(item => `‚Ä¢ ${item}`).join('<br>') : 
                            slide.content || '';
                            
                        slideElement.innerHTML = `
                            <div class="slide-title">Slide ${index + 1}: ${slide.title}</div>
                            <div class="slide-content">${contentList}</div>
                            ${slide.notes ? `<div style="margin-top:10px; font-style:italic; color:#9ca3af;">Notes: ${slide.notes}</div>` : ''}
                        `;
                    }
                    
                    slidePreview.appendChild(slideElement);
                });
                
                previewSection.style.display = 'block';
            }

            async readTemplateFile(file) {
                const arrayBuffer = await file.arrayBuffer();
                const zip = new JSZip();
                const zipData = await zip.loadAsync(arrayBuffer);
                
                // Extract comprehensive template information
                const templateData = {
                    originalZip: zipData,
                    slideLayouts: {},
                    slideMasters: {},
                    themes: {},
                    media: {},
                    presentation: null,
                    relationships: {},
                    contentTypes: null,
                    docProps: {}
                };

                // Read presentation.xml to understand structure
                if (zipData.files['ppt/presentation.xml']) {
                    templateData.presentation = await zipData.file('ppt/presentation.xml').async('text');
                }

                // Read slide layouts
                const slideLayoutFiles = Object.keys(zipData.files).filter(name => 
                    name.startsWith('ppt/slideLayouts/') && name.endsWith('.xml')
                );

                for (const layoutFile of slideLayoutFiles) {
                    const content = await zipData.file(layoutFile).async('text');
                    templateData.slideLayouts[layoutFile] = content;
                }

                // Read slide masters
                const slideMasterFiles = Object.keys(zipData.files).filter(name => 
                    name.startsWith('ppt/slideMasters/') && name.endsWith('.xml')
                );

                for (const masterFile of slideMasterFiles) {
                    const content = await zipData.file(masterFile).async('text');
                    templateData.slideMasters[masterFile] = content;
                }

                // Read theme information
                const themeFiles = Object.keys(zipData.files).filter(name => 
                    name.startsWith('ppt/theme/') && name.endsWith('.xml')
                );

                for (const themeFile of themeFiles) {
                    const content = await zipData.file(themeFile).async('text');
                    templateData.themes[themeFile] = content;
                }

                // Read all relationship files
                const relationshipFiles = Object.keys(zipData.files).filter(name => 
                    name.endsWith('.rels')
                );

                for (const relFile of relationshipFiles) {
                    const content = await zipData.file(relFile).async('text');
                    templateData.relationships[relFile] = content;
                }

                // Read content types
                if (zipData.files['[Content_Types].xml']) {
                    templateData.contentTypes = await zipData.file('[Content_Types].xml').async('text');
                }

                // Read document properties
                const docPropFiles = Object.keys(zipData.files).filter(name => 
                    name.startsWith('docProps/')
                );

                for (const docFile of docPropFiles) {
                    const content = await zipData.file(docFile).async('text');
                    templateData.docProps[docFile] = content;
                }

                // Read media files
                const mediaFiles = Object.keys(zipData.files).filter(name => 
                    name.startsWith('ppt/media/')
                );

                for (const mediaFile of mediaFiles) {
                    const content = await zipData.file(mediaFile).async('arraybuffer');
                    templateData.media[mediaFile] = content;
                }

                return templateData;
            }

            async generatePowerPointWithTemplate(slideData, templateData) {
                const zip = new JSZip();
                
                // Copy all template structure first
                await this.copyTemplateStructure(zip, templateData);
                
                // Generate slides using template layouts
                await this.generateSlidesWithTemplate(zip, slideData, templateData);
                
                // Update presentation.xml with new slides
                await this.updatePresentationXml(zip, slideData, templateData);
                
                // Update content types
                await this.updateContentTypes(zip, slideData.slides.length);
                
                // Update relationships
                await this.updateRelationships(zip, slideData.slides.length, templateData);
                
                // Generate the final PPTX file
                const blob = await zip.generateAsync({ type: 'blob' });
                return blob;
            }

            async copyTemplateStructure(zip, templateData) {
                // Copy all non-slide files from template
                for (const [path, content] of Object.entries(templateData.originalZip.files)) {
                    if (!path.startsWith('ppt/slides/slide') && 
                        !path.startsWith('ppt/slides/_rels/slide') &&
                        content.dir === false) {
                        
                        if (typeof content._data === 'string' || content._data instanceof Uint8Array) {
                            const data = await templateData.originalZip.file(path).async('arraybuffer');
                            zip.file(path, data);
                        }
                    }
                }
            }

            async generateSlidesWithTemplate(zip, slideData, templateData) {
                const slides = slideData.slides;
                
                // Get the first slide layout as a template
                const layoutKeys = Object.keys(templateData.slideLayouts);
                const firstLayoutKey = layoutKeys[0];
                const layoutTemplate = templateData.slideLayouts[firstLayoutKey];
                
                slides.forEach((slide, index) => {
                    const slideNumber = index + 1;
                    const slideXml = this.generateSlideWithTemplateLayout(slide, slideNumber, layoutTemplate, templateData);
                    zip.file(`ppt/slides/slide${slideNumber}.xml`, slideXml);
                    
                    // Generate slide relationship
                    const slideRelsXml = this.generateSlideRelsWithTemplate(slideNumber, templateData);
                    zip.file(`ppt/slides/_rels/slide${slideNumber}.xml.rels`, slideRelsXml);
                });
            }

            generateSlideWithTemplateLayout(slide, slideNumber, layoutTemplate, templateData) {
                // Extract layout structure and apply content
                let slideXml = layoutTemplate;
                
                // Replace layout references with slide references
                slideXml = slideXml.replace(/<p:sldLayout[^>]*>/, '<p:sld xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/